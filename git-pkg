#!/bin/bash

set -o errexit

__doc__="\
GIT PKG
  A custom git command to install software from a github release.
  See https://github.com/archf/git-pkg.

Limitations
Using the 'latest release' will only work if the release is not tagged as a
'draft' or 'prerelease'.

USAGE
  git pkg [OPTIONS] CMD <repo_spec>

OPTIONS
  -h|--help       Show this help menu.
  -t|--tag        Output latest release 'tag_name'.
  -p|--pattern    Pattern to select asset by name. PCRE regex are supported.
                  The match is done against the name only, not the download url
  --asset-tmp-dir Temporary dir where to download Debian archives.
  --b|--bin-dir   Directory where to unpack a tar archive typically containing
                  a binary executable. Defaults to '~/bin'. A Typicall
                  alternative would be '/usr/local/bin'.
  -u|--update     update package
  -v|--verbose

CMD
  show        List git 'templatedir' available hooks.
  install     Install hooks found inside git 'templatedir' in repository.
              Current hooks are backed up to '.git/hooks.old'. If the hook is
              already found in '.git/hooks.old' it will be skipped unless you
              delete it manually or use the --force option.
  search      Search for assets
  help        Show this help menu.
"

function _help() { echo "${__doc__:-No usage available}" 1>&2; }

# Alternate simpler logging system.
verbose() { if [ -n "$VERBOSE" ]; then printf "%s\n" "$*" 1>&2; fi; }
echoerr() { echo "$@" 1>&2; }

die_with_status () {
	local status=$1
  shift; printf >&2 '%s\n' "$*"; exit "$status"
}

die() { die_with_status 1 "$@"; }

while [ $# -gt 1 ]; do
  case $1 in
    install|search) cmd=$1;;
    -v|--verbose) VERBOSE=true;;
    -n|--dry-run) DRY_RUN=true;;
    -h|--help|help) cmd=help;;
    -t|--tag) __tag=true;;
    -b|--bin-dir) shift; __bin_dir=$1;;
    --asset-tmp-dir) shift;  __asset_tmp_dir=$1;;
    -p|--pattern) shift; __pattern=$1;;
    *) die "Invalid positional argument: '$1'";;
    --) shift; break;;
  esac
  shift
done

cmd=${cmd:-help}

verbose "'VERBOSE': ${VERBOSE}"
# verbose "'DRY_RUN': ${DRY_RUN:-}"
# verbose "'FORCE': ${FORCE:-}"

verbose "'cmd': ${cmd:-}"
verbose "'__tag': ${__tag:-}"
verbose "'__asset_tmp_dir': ${__asset_tmp_dir:-}"
verbose "'pattern': ${__pattern:-}"

function _search() {
  local repo_spec=$1

  if [[ $__tag ]]; then
    curl --silent "https://api.github.com/repos/$repo_spec/releases/latest" | jq -r '.["tag_name"]'
    return
  fi

  curl --silent "https://api.github.com/repos/$repo_spec/releases/latest" \
    | jq --raw-output --arg ASSET_PATTERN ${__pattern:-".*"} \
    '.["assets"][] | select(.["name"]|test($ASSET_PATTERN)) | .["browser_download_url"]'

}

function _mkdir() {
  local var=${1}
  local path=${!var:-$2}
  if [ -z ${!var} ]; then
    echoerr "Option '${var}' undefined, using default directory '${path}'"
  fi
  mkdir -p ${path}
}

function _install() {
  local asset_url=$(_search $@)
  verbose "'asset_url': ${asset_url:-}"

  # FIXME: handle zero assets returned situation
  if [ $(wc --words <<< ${asset_url}) -gt 1 ]; then
    die "Error: too many possible asset to download. Possible matches are
    ${asset_url/ /}

    ${asset_url##\t}
    Consider using a more specific asset filtering pattern. See option '-p|--pattern'"
  fi

  case $asset_url in
    *tar.*) _mkdir __bin_dir  ~/bin ;;&
    *tar.txz)
      curl --silent --location $asset_url \
        | tar --extract -f - -J --directory ${__bin_dir};;
    *.deb)
      # debian archives offers no way to install from remote URL as far as I am
      # aware of. Thus we must download archive to disk

      _mkdir __asset_tmp_dir  ~/Downloads
      curl --silent --location --output ${__asset_tmp_dir}/${asset_url##*/} ${asset_url}
      sudo apt install ${__asset_tmp_dir}/${asset_url##*/}
      ;;
  esac
}

_$cmd $@
